<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>时光修复师 - 智能修复工作台</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body {
            font-family: "PingFang SC", "Microsoft YaHei", sans-serif;
            background-color: #0f172a;
            color: #e2e8f0;
        }
        
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        /* --- 放大镜核心样式 --- */
        .img-zoom-container {
            position: relative;
            width: 100%;
            overflow: hidden;
            border-radius: 8px;
            cursor: crosshair;
        }

        .zoom-source-img {
            width: 100%;
            height: auto;
            display: block;
            filter: brightness(0.9); 
        }

        .img-zoom-lens {
            position: absolute;
            border: 2px solid #f59e0b;
            background-color: rgba(255, 255, 255, 0.2);
            width: 100px;
            height: 100px;
            z-index: 10;
            pointer-events: none;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            display: none;
        }

        .img-zoom-result {
            width: 100%;
            min-height: 400px; 
            height: 100%;
            border-radius: 8px;
            background-repeat: no-repeat;
            background-color: #1e293b;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
            border: 1px solid #334155;
            position: relative;
        }
        
        .result-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #64748b;
            font-size: 14px;
            pointer-events: none;
            text-align: center;
        }

        /* 自定义滑块样式 */
        input[type=range] {
            -webkit-appearance: none;
            width: 120px;
            height: 6px;
            background: #334155;
            border-radius: 3px;
            outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #f59e0b;
            cursor: pointer;
            transition: background .15s ease-in-out;
        }
        input[type=range]::-webkit-slider-thumb:hover {
            background: #d97706;
        }

        /* --- 扫描动画核心样式 (完美对齐修正版) --- */
        
        .scanner-container {
            width: 100%;
            background-color: #1e293b;
            border-radius: 12px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
            padding: 20px; 
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .scanner-stage {
            position: relative;
            display: inline-flex; 
            line-height: 0; 
            max-width: 100%;
            max-height: 80vh; 
            /* 定义CSS变量控制时长，默认4s */
            --scan-duration: 4s; 
        }

        .scanner-base-img {
            display: block;
            width: auto;
            height: auto;
            max-width: 100%;
            max-height: 80vh;
        }

        .scanner-reveal-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0; 
            width: 0%; 
            overflow: hidden;
            z-index: 10;
            border-right: 1px solid rgba(255,255,255,0.4);
            box-sizing: border-box; 
        }
        
        .scanner-reveal-img {
            max-width: none; 
            display: block;
        }

        .scan-line {
            position: absolute;
            z-index: 20;
            background: #f59e0b;
            box-shadow: 0 0 15px 2px #f59e0b, 0 0 5px #fff;
            opacity: 0; 
            pointer-events: none;
        }

        /* --- 动画关键帧 --- */
        @keyframes wrapperWidth {
            0% { width: 0%; border-right-width: 0; }
            5% { width: 0%; border-right-width: 2px; }
            60% { width: 100%; border-right-width: 2px; }
            85% { width: 100%; border-right-width: 0; }
            100% { width: 100%; border-right-width: 0; }
        }
        @keyframes lineMoveH {
            0% { left: 0%; opacity: 0; height: 100%; width: 2px; top: 0; }
            5% { left: 0%; opacity: 1; }
            60% { left: 100%; opacity: 1; }
            61% { left: 100%; opacity: 0; }
            100% { left: 100%; opacity: 0; height: 100%; width: 2px; top: 0; }
        }

        @keyframes wrapperHeight {
            0% { height: 0%; border-bottom-width: 0; width: 100%; border-right: none; }
            5% { height: 0%; border-bottom-width: 2px; }
            60% { height: 100%; border-bottom-width: 2px; }
            85% { height: 100%; border-bottom-width: 0; }
            100% { height: 100%; border-bottom-width: 0; width: 100%; border-right: none; }
        }
        @keyframes lineMoveV {
            0% { top: 0%; opacity: 0; width: 100%; height: 2px; left: 0; }
            5% { top: 0%; opacity: 1; }
            60% { top: 100%; opacity: 1; }
            61% { top: 100%; opacity: 0; }
            100% { top: 100%; opacity: 0; width: 100%; height: 2px; left: 0; }
        }

        /* 应用动画：使用 var(--scan-duration) 替代固定时长 */
        .animate-scan-h .scanner-reveal-wrapper {
            animation: wrapperWidth var(--scan-duration) ease-in-out infinite;
            height: 100% !important; 
        }
        .animate-scan-h .scan-line {
            animation: lineMoveH var(--scan-duration) ease-in-out infinite;
        }

        .animate-scan-v .scanner-reveal-wrapper {
            animation: wrapperHeight var(--scan-duration) ease-in-out infinite;
            width: 100% !important; 
            border-right: none;
            border-bottom: 1px solid rgba(255,255,255,0.4);
        }
        .animate-scan-v .scan-line {
            animation: lineMoveV var(--scan-duration) ease-in-out infinite;
        }
        
        .paused .scanner-reveal-wrapper, .paused .scan-line {
            animation-play-state: paused;
        }

        /* 加载状态动画 */
        @keyframes spin { 100% { transform: rotate(360deg); } }
        .spinner { animation: spin 1s linear infinite; }

        /* 自定义下拉菜单样式 */
        .custom-select {
            appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%2394a3b8' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }

    </style>
</head>
<body class="min-h-screen flex flex-col">

    <!-- 顶部导航 -->
    <header class="w-full py-4 px-4 border-b border-slate-800 bg-slate-900 z-50">
        <div class="max-w-6xl mx-auto flex flex-col lg:flex-row justify-between items-center gap-4">
            <div class="flex items-center gap-2 mb-2 lg:mb-0">
                <i data-lucide="scan-face" class="text-amber-500"></i>
                <h1 class="text-xl font-bold tracking-wider text-slate-100">TIME TRACE <span class="text-xs text-slate-400 font-normal ml-2">智能修复工作台</span></h1>
            </div>
            
            <div class="flex flex-col sm:flex-row gap-3 w-full lg:w-auto">
                <div class="flex items-center bg-slate-800 rounded-lg p-1 ring-1 ring-slate-700 focus-within:ring-amber-500 focus-within:ring-2 transition-all">
                    <label class="cursor-pointer px-3 py-2 hover:bg-slate-700 rounded text-slate-400 hover:text-white transition-colors flex items-center gap-2" title="上传本地图片">
                        <input type="file" id="uploadBefore" accept="image/*" class="hidden">
                        <i data-lucide="upload" class="w-4 h-4"></i>
                        <span class="text-xs font-bold md:hidden">上传原图</span>
                    </label>
                    <div class="w-px h-5 bg-slate-700 mx-1"></div>
                    <input type="text" id="urlBefore" placeholder="链接 (blob: 支持)" class="bg-transparent border-none focus:outline-none text-xs text-slate-200 w-full sm:w-48 px-2 placeholder-slate-600">
                </div>
                <div class="flex items-center bg-slate-800 rounded-lg p-1 ring-1 ring-slate-700 focus-within:ring-amber-500 focus-within:ring-2 transition-all">
                    <label class="cursor-pointer px-3 py-2 hover:bg-slate-700 rounded text-amber-600/80 hover:text-amber-500 transition-colors flex items-center gap-2" title="上传本地图片">
                        <input type="file" id="uploadAfter" accept="image/*" class="hidden">
                        <i data-lucide="upload" class="w-4 h-4"></i>
                        <span class="text-xs font-bold md:hidden">上传精修</span>
                    </label>
                    <div class="w-px h-5 bg-slate-700 mx-1"></div>
                    <input type="text" id="urlAfter" placeholder="链接 (blob: 支持)" class="bg-transparent border-none focus:outline-none text-xs text-slate-200 w-full sm:w-48 px-2 placeholder-slate-600">
                </div>
            </div>
        </div>
    </header>

    <main class="flex-grow pt-8 pb-12 px-4">
        <div class="max-w-6xl mx-auto space-y-16">

            <!-- 第一部分：高清细节放大镜 -->
            <section>
                <div class="mb-4 flex flex-col md:flex-row justify-between md:items-end gap-2">
                    <div>
                        <h2 class="text-2xl font-bold text-slate-100 flex items-center gap-2">
                            高清细节透镜
                        </h2>
                        <p class="text-slate-400 text-sm mt-1">
                            鼠标在<span class="text-amber-500">左侧原图</span>移动，右侧显示细节
                        </p>
                    </div>
                    <!-- 滑块控件 -->
                    <div class="flex items-center gap-4 bg-slate-800 px-4 py-2 rounded-lg text-xs text-slate-300 ring-1 ring-slate-700">
                        <span class="text-slate-400">透镜大小:</span>
                        <div class="flex items-center gap-2">
                            <i data-lucide="minus" class="w-3 h-3 text-slate-500"></i>
                            <input type="range" id="lensSizeSlider" min="1.5" max="6" step="0.1" value="3">
                            <i data-lucide="plus" class="w-3 h-3 text-slate-500"></i>
                        </div>
                        <span id="zoomLevelDisplay" class="font-mono text-amber-500 w-12 text-right">3.0x</span>
                    </div>
                </div>

                <!-- 图片网格容器 -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-8">
                    <!-- 左侧：Before (带透镜) -->
                    <div class="relative group">
                        <div class="absolute top-2 left-2 z-20 px-2 py-1 bg-black/70 backdrop-blur text-white text-xs rounded border border-white/10 pointer-events-none">
                            Before / 修复前
                        </div>
                        <div class="img-zoom-container" id="imgContainer">
                            <div id="zoomLens" class="img-zoom-lens"></div>
                            <img id="beforeImg" 
                                 crossOrigin="anonymous"
                                 src="https://images.unsplash.com/photo-1544005313-94ddf0286df2?q=80&w=800&auto=format&fit=crop" 
                                 class="zoom-source-img" 
                                 style="filter: grayscale(100%) sepia(30%) contrast(1.2);"
                                 alt="Before Image"
                                 onerror="this.src='https://placehold.co/600x400?text=Image+Error';">
                        </div>
                    </div>
                    <!-- 右侧：After (放大结果) -->
                    <div class="relative h-full min-h-[300px] md:min-h-[auto]">
                        <div class="absolute top-2 right-2 z-20 px-2 py-1 bg-amber-600/90 backdrop-blur text-white text-xs rounded shadow-lg pointer-events-none">
                            After / 修复后
                        </div>
                        <div id="zoomResult" class="img-zoom-result">
                            <div class="result-hint flex flex-col items-center gap-2">
                                <i data-lucide="search" class="w-6 h-6"></i>
                                <span>移动左侧透镜查看细节</span>
                            </div>
                        </div>
                    </div>
                </div>
            </section>


            <!-- 第二部分：AI 智能扫描演示 -->
            <section class="border-t border-slate-800 pt-12">
                <div class="mb-6 flex flex-col md:flex-row justify-between items-end gap-4">
                    <div>
                        <h2 class="text-2xl font-bold text-slate-100 flex items-center gap-2">
                            <i data-lucide="wand-2" class="text-amber-500 w-6 h-6"></i>
                            AI 修复过程演示
                        </h2>
                        <p class="text-slate-400 text-sm mt-1">自动识别照片方向，模拟智能修复扫描过程。</p>
                    </div>
                    
                    <!-- 扫描控制 -->
                    <div class="flex flex-wrap gap-2 items-center">
                         <button onclick="toggleScanPause()" id="btnPause" class="px-3 py-1.5 bg-slate-800 hover:bg-slate-700 text-slate-300 text-xs rounded border border-slate-700 flex items-center gap-2 transition-colors">
                            <i data-lucide="pause" class="w-3 h-3"></i> 暂停
                         </button>
                         
                         <!-- 速度选择器 -->
                         <div class="relative flex items-center">
                            <i data-lucide="timer" class="absolute left-2 w-3 h-3 text-slate-500 z-10"></i>
                            <select id="scanSpeed" class="custom-select pl-7 pr-8 py-1.5 bg-slate-800 hover:bg-slate-700 text-slate-300 text-xs rounded border border-slate-700 transition-colors outline-none cursor-pointer">
                                <option value="0.1">0.1x (超慢)</option>
                                <option value="0.25">0.25x (极慢)</option>
                                <option value="0.5">0.5x (慢速)</option>
                                <option value="1.0" selected>1.0x (默认)</option>
                                <option value="1.5">1.5x (稍快)</option>
                                <option value="2.0">2.0x (快速)</option>
                            </select>
                         </div>

                         <div class="h-6 w-px bg-slate-700 mx-1 hidden sm:block"></div>

                         <button onclick="forceScanDirection('h')" class="px-3 py-1.5 bg-slate-800 hover:bg-slate-700 text-slate-300 text-xs rounded border border-slate-700 transition-colors">
                            ↔ 横向
                         </button>
                         <button onclick="forceScanDirection('v')" class="px-3 py-1.5 bg-slate-800 hover:bg-slate-700 text-slate-300 text-xs rounded border border-slate-700 transition-colors">
                            ↕ 纵向
                         </button>
                         <!-- 下载按钮 -->
                         <button onclick="generateVideo()" id="btnDownload" class="px-3 py-1.5 bg-amber-600 hover:bg-amber-500 text-white text-xs rounded border border-amber-500 flex items-center gap-2 transition-colors shadow-lg shadow-amber-900/20">
                            <i data-lucide="video" class="w-3 h-3"></i> 下载 MP4
                         </button>
                    </div>
                </div>

                <!-- 扫描容器 (新结构) -->
                <div class="scanner-container" id="scannerContainer">
                    <div class="scanner-stage animate-scan-h" id="scannerStage">
                        <img id="scanBefore" 
                             crossOrigin="anonymous"
                             src="https://images.unsplash.com/photo-1544005313-94ddf0286df2?q=80&w=800&auto=format&fit=crop" 
                             class="scanner-base-img"
                             style="filter: grayscale(100%) sepia(30%) contrast(1.2);">
                        
                        <div class="scan-line"></div>

                        <div class="scanner-reveal-wrapper" id="scannerWrapper">
                            <img id="scanAfter" 
                                 crossOrigin="anonymous"
                                 src="https://images.unsplash.com/photo-1544005313-94ddf0286df2?q=80&w=800&auto=format&fit=crop" 
                                 class="scanner-reveal-img">
                        </div>
                    </div>
                </div>
            </section>


            <!-- 第三部分：全图预览与比对 -->
            <section class="border-t border-slate-800 pt-12">
                <div class="mb-6 flex flex-col md:flex-row justify-between items-end gap-4">
                    <div>
                        <h2 class="text-2xl font-bold text-slate-100 flex items-center gap-2">
                            <i data-lucide="images" class="text-amber-500 w-6 h-6"></i>
                            全图效果比对
                        </h2>
                        <p class="text-slate-400 text-sm mt-1">完整视角的修复前后对比，可一键生成对比图发给客户。</p>
                    </div>
                    
                    <!-- 新增：截图复制与下载 -->
                    <div class="flex gap-2">
                        <button onclick="copyComparison()" id="btnCopyComp" class="px-3 py-1.5 bg-slate-800 hover:bg-slate-700 text-slate-300 text-xs rounded border border-slate-700 flex items-center gap-2 transition-colors">
                            <i data-lucide="clipboard-copy" class="w-3 h-3"></i> 复制对比图
                        </button>
                        <button onclick="downloadComparison()" id="btnDownComp" class="px-3 py-1.5 bg-slate-800 hover:bg-slate-700 text-slate-300 text-xs rounded border border-slate-700 flex items-center gap-2 transition-colors">
                            <i data-lucide="download" class="w-3 h-3"></i> 下载对比图
                        </button>
                    </div>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-8 items-start">
                     <!-- Before 卡片 -->
                     <div class="relative group bg-slate-800 rounded-xl p-2 ring-1 ring-slate-700 transition-all duration-300 hover:ring-amber-500/50">
                         <div class="relative w-full overflow-hidden rounded-lg bg-slate-900/50 min-h-[200px] flex items-center justify-center">
                             <img id="previewBefore" 
                                  crossOrigin="anonymous"
                                  src="https://images.unsplash.com/photo-1544005313-94ddf0286df2?q=80&w=800&auto=format&fit=crop" 
                                  class="w-full h-auto max-h-[80vh] object-contain mx-auto"
                                  style="display: block; filter: grayscale(100%) sepia(30%) contrast(1.2);">
                             <div class="absolute top-3 left-3 px-3 py-1 bg-black/60 backdrop-blur-sm text-slate-200 text-xs font-bold rounded border border-white/10 z-10 pointer-events-none">
                                 BEFORE / 原片
                             </div>
                         </div>
                     </div>

                     <!-- After 卡片 -->
                     <div class="relative group bg-slate-800 rounded-xl p-2 ring-1 ring-slate-700 transition-all duration-300 hover:ring-amber-500/50">
                         <div class="relative w-full overflow-hidden rounded-lg bg-slate-900/50 min-h-[200px] flex items-center justify-center">
                             <img id="previewAfter" 
                                  crossOrigin="anonymous"
                                  src="https://images.unsplash.com/photo-1544005313-94ddf0286df2?q=80&w=2000&auto=format&fit=crop" 
                                  class="w-full h-auto max-h-[80vh] object-contain mx-auto"
                                  style="display: block;">
                             <div class="absolute top-3 left-3 px-3 py-1 bg-amber-600/90 backdrop-blur-sm text-white text-xs font-bold rounded shadow-lg z-10 pointer-events-none">
                                 AFTER / 精修
                             </div>
                         </div>
                     </div>
                </div>
            </section>

        </div>
    </main>

    <footer class="border-t border-slate-800 py-8 mt-12">
        <div class="text-center text-slate-500 text-sm">
            <p>&copy; 2025 时光修复师</p>
        </div>
    </footer>

    <script>
        lucide.createIcons();

        // --- 变量定义 ---
        const beforeImg = document.getElementById('beforeImg');
        const zoomResult = document.getElementById('zoomResult');
        const zoomLens = document.getElementById('zoomLens');
        const imgContainer = document.getElementById('imgContainer');
        const lensSizeSlider = document.getElementById('lensSizeSlider');
        const zoomLevelDisplay = document.getElementById('zoomLevelDisplay');
        const resultHint = document.querySelector('.result-hint');

        const scannerContainer = document.getElementById('scannerContainer');
        const scannerStage = document.getElementById('scannerStage'); 
        const scanBefore = document.getElementById('scanBefore');
        const scanAfter = document.getElementById('scanAfter');
        const scannerWrapper = document.getElementById('scannerWrapper');
        const btnPause = document.getElementById('btnPause');
        const btnDownload = document.getElementById('btnDownload');
        const scanSpeed = document.getElementById('scanSpeed'); 

        const previewBefore = document.getElementById('previewBefore');
        const previewAfter = document.getElementById('previewAfter');
        const btnCopyComp = document.getElementById('btnCopyComp');
        const btnDownComp = document.getElementById('btnDownComp');

        const uploadBefore = document.getElementById('uploadBefore');
        const uploadAfter = document.getElementById('uploadAfter');
        const urlBefore = document.getElementById('urlBefore');
        const urlAfter = document.getElementById('urlAfter');

        let afterImgUrl = "https://images.unsplash.com/photo-1544005313-94ddf0286df2?q=80&w=2000&auto=format&fit=crop";
        let lastCursorX = 0, lastCursorY = 0, isCursorInside = false;

        // --- 1. 扫描动画逻辑 ---

        function syncScannerImageSize() {
            const width = scanBefore.offsetWidth;
            const height = scanBefore.offsetHeight;
            
            if (width === 0 || height === 0) return;

            scanAfter.style.width = width + 'px';
            scanAfter.style.height = height + 'px';
        }

        function detectScanDirection() {
            scannerStage.classList.remove('animate-scan-h', 'animate-scan-v');
            if (scanBefore.naturalWidth > scanBefore.naturalHeight) {
                scannerStage.classList.add('animate-scan-h');
                return 'h';
            } else {
                scannerStage.classList.add('animate-scan-v');
                return 'v';
            }
        }

        window.forceScanDirection = function(dir) {
            scannerStage.classList.remove('animate-scan-h', 'animate-scan-v');
            if(dir === 'h') scannerStage.classList.add('animate-scan-h');
            else scannerStage.classList.add('animate-scan-v');
            syncScannerImageSize();
        }

        window.toggleScanPause = function() {
            scannerStage.classList.toggle('paused');
            const isPaused = scannerStage.classList.contains('paused');
            const icon = isPaused ? 'play' : 'pause';
            btnPause.innerHTML = `<i data-lucide="${icon}" class="w-3 h-3"></i> ${isPaused ? '继续' : '暂停'}`;
            lucide.createIcons();
        }

        window.updateScanSpeed = function() {
            const speed = parseFloat(scanSpeed.value);
            const baseDuration = 4; 
            const newDuration = baseDuration / speed;
            scannerStage.style.setProperty('--scan-duration', newDuration + 's');
        }

        scanSpeed.addEventListener('change', window.updateScanSpeed);
        window.addEventListener('resize', syncScannerImageSize);

        // --- 2. 视频生成逻辑 ---
        
        window.generateVideo = function() {
            if (typeof MediaRecorder === 'undefined') {
                alert("抱歉，您的浏览器不支持视频录制功能。");
                return;
            }

            const originalBtnHtml = btnDownload.innerHTML;
            btnDownload.innerHTML = `<i data-lucide="loader" class="w-3 h-3 spinner"></i> 正在生成...`;
            btnDownload.disabled = true;
            lucide.createIcons();

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const width = scanBefore.naturalWidth;
            const height = scanBefore.naturalHeight;
            canvas.width = width;
            canvas.height = height;

            const isHorizontal = scanBefore.naturalWidth > scanBefore.naturalHeight;

            let mimeType = 'video/webm'; 
            let ext = 'webm';

            if (MediaRecorder.isTypeSupported('video/mp4;codecs=avc1.42E01E,mp4a.40.2')) {
                mimeType = 'video/mp4;codecs=avc1.42E01E,mp4a.40.2';
                ext = 'mp4';
            } else if (MediaRecorder.isTypeSupported('video/mp4')) {
                mimeType = 'video/mp4';
                ext = 'mp4';
            } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                mimeType = 'video/webm;codecs=vp9';
            }

            console.log(`Using MIME type: ${mimeType}`);

            let recorder;
            try {
                const stream = canvas.captureStream(30);
                recorder = new MediaRecorder(stream, { mimeType: mimeType });
            } catch (e) {
                console.warn("Fallback to default mimeType");
                recorder = new MediaRecorder(canvas.captureStream(30));
                ext = 'webm';
            }
            
            const chunks = [];
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: mimeType.split(';')[0] });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `修复对比演示_${new Date().getTime()}.${ext}`;
                a.click();
                
                btnDownload.innerHTML = originalBtnHtml;
                btnDownload.disabled = false;
                lucide.createIcons();
            };

            recorder.start();

            const speed = parseFloat(scanSpeed.value);
            const baseDuration = 4000;
            const duration = baseDuration / speed; 
            
            const startTime = performance.now();

            function drawFrame(now) {
                const elapsed = now - startTime;
                let progress = 0;
                const p = elapsed / duration;

                if (p <= 0.05) progress = 0;
                else if (p <= 0.60) progress = (p - 0.05) / 0.55;
                else progress = 1;

                ctx.clearRect(0, 0, width, height);
                
                try {
                    ctx.drawImage(scanBefore, 0, 0, width, height);
                } catch(e) {
                    alert("跨域安全限制，无法录制此网络图片。请使用本地图片。");
                    recorder.stop();
                    return; 
                }

                if (isHorizontal) {
                    const w = width * progress;
                    if (w > 0) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(0, 0, w, height);
                        ctx.clip();
                        ctx.drawImage(scanAfter, 0, 0, width, height);
                        ctx.restore();
                        
                        if (progress < 1 && progress > 0) {
                            ctx.beginPath();
                            ctx.moveTo(w, 0);
                            ctx.lineTo(w, height);
                            ctx.lineWidth = 4 * (width / 800);
                            ctx.strokeStyle = '#f59e0b';
                            ctx.shadowColor = '#f59e0b';
                            ctx.shadowBlur = 20;
                            ctx.stroke();
                        }
                    }
                } else {
                    const h = height * progress;
                    if (h > 0) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(0, 0, width, h);
                        ctx.clip();
                        ctx.drawImage(scanAfter, 0, 0, width, height);
                        ctx.restore();
                        
                        if (progress < 1 && progress > 0) {
                            ctx.beginPath();
                            ctx.moveTo(0, h);
                            ctx.lineTo(width, h);
                            ctx.lineWidth = 4 * (height / 800);
                            ctx.strokeStyle = '#f59e0b';
                            ctx.shadowColor = '#f59e0b';
                            ctx.shadowBlur = 20;
                            ctx.stroke();
                        }
                    }
                }
                
                if (elapsed < duration) requestAnimationFrame(drawFrame);
                else recorder.stop();
            }

            requestAnimationFrame(drawFrame);
        }

        // --- 5. 合成图生成逻辑 (修复版) ---

        function createComparisonCanvas() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            const imgWidth = previewBefore.naturalWidth;
            const imgHeight = previewBefore.naturalHeight;
            const gap = Math.max(20, imgWidth * 0.05); 
            const headerHeight = Math.max(80, imgHeight * 0.15); 
            const footerHeight = Math.max(60, imgHeight * 0.1); 
            const padding = Math.max(20, imgWidth * 0.05); 

            const totalWidth = (imgWidth * 2) + gap + (padding * 2);
            const totalHeight = imgHeight + headerHeight + footerHeight;

            canvas.width = totalWidth;
            canvas.height = totalHeight;

            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, totalWidth, totalHeight);

            try {
                ctx.drawImage(previewBefore, padding, headerHeight, imgWidth, imgHeight);
                ctx.drawImage(previewAfter, padding + imgWidth + gap, headerHeight, imgWidth, imgHeight);
            } catch(e) {
                alert('图片加载失败或存在跨域问题，无法生成对比图。');
                return null;
            }

            function drawLabel(text, x, y, color) {
                ctx.font = `bold ${Math.max(24, imgHeight * 0.04)}px "Microsoft YaHei"`;
                const metrics = ctx.measureText(text);
                const bgWidth = metrics.width + 40;
                const bgHeight = Math.max(40, imgHeight * 0.06);
                
                ctx.fillStyle = color;
                ctx.roundRect ? ctx.roundRect(x, y, bgWidth, bgHeight, 8) : ctx.fillRect(x, y, bgWidth, bgHeight);
                ctx.fill();

                ctx.fillStyle = '#ffffff';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, x + 20, y + (bgHeight / 2));
            }

            drawLabel('BEFORE / 原片', padding + 20, headerHeight + 20, 'rgba(0, 0, 0, 0.7)');
            drawLabel('AFTER / 精修', padding + imgWidth + gap + 20, headerHeight + 20, 'rgba(217, 119, 6, 0.9)');

            ctx.font = `bold ${Math.max(36, imgHeight * 0.06)}px "Microsoft YaHei"`;
            ctx.fillStyle = '#f59e0b';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('修复效果对比', totalWidth / 2, headerHeight / 2);

            ctx.font = `${Math.max(20, imgHeight * 0.03)}px "Microsoft YaHei"`;
            ctx.fillStyle = '#64748b';
            ctx.fillText('Generated by 时光修复师', totalWidth / 2, totalHeight - (footerHeight / 2));

            return canvas;
        }

        // 功能 1: 复制到剪贴板 (严谨模式 - 移除虚假 Fallback)
        window.copyComparison = function() {
            const originalHtml = btnCopyComp.innerHTML;
            btnCopyComp.innerHTML = `<i data-lucide="loader" class="w-3 h-3 spinner"></i> 生成中...`;
            lucide.createIcons();

            setTimeout(() => {
                const canvas = createComparisonCanvas();
                if (!canvas) {
                    btnCopyComp.innerHTML = originalHtml;
                    lucide.createIcons();
                    return;
                }

                canvas.toBlob(blob => {
                    const handleSuccess = () => {
                        btnCopyComp.innerHTML = `<i data-lucide="check" class="w-3 h-3"></i> 已复制!`;
                        btnCopyComp.classList.add('text-green-400', 'border-green-400');
                        lucide.createIcons();
                        setTimeout(() => {
                            btnCopyComp.innerHTML = originalHtml;
                            btnCopyComp.classList.remove('text-green-400', 'border-green-400');
                            lucide.createIcons();
                        }, 2000);
                    };

                    const handleFail = (msg) => {
                        console.error('Copy failed:', msg);
                        // 明确告知用户复制受限
                        btnCopyComp.innerHTML = `<i data-lucide="x" class="w-3 h-3"></i> 复制受限,请下载`;
                        btnCopyComp.classList.add('text-red-400', 'border-red-400');
                        lucide.createIcons();
                        setTimeout(() => {
                            btnCopyComp.innerHTML = originalHtml;
                            btnCopyComp.classList.remove('text-red-400', 'border-red-400');
                            lucide.createIcons();
                        }, 3000);
                    };

                    // 核心修改：仅使用标准 API，如果失败则报错，不使用无效的 fallback
                    if (navigator.clipboard && navigator.clipboard.write) {
                        try {
                            const item = new ClipboardItem({ 'image/png': blob });
                            navigator.clipboard.write([item])
                                .then(handleSuccess)
                                .catch(err => handleFail(err));
                        } catch (err) {
                            handleFail(err);
                        }
                    } else {
                        handleFail('Clipboard API not supported');
                    }
                }, 'image/png'); // 明确指定 PNG 格式
            }, 50);
        }

        // 功能 2: 下载图片
        window.downloadComparison = function() {
            const originalHtml = btnDownComp.innerHTML;
            btnDownComp.innerHTML = `<i data-lucide="loader" class="w-3 h-3 spinner"></i> 下载中...`;
            lucide.createIcons();

            setTimeout(() => {
                const canvas = createComparisonCanvas();
                if (canvas) {
                    const link = document.createElement('a');
                    link.download = `修复对比图_${new Date().getTime()}.png`;
                    link.href = canvas.toDataURL();
                    link.click();
                }
                btnDownComp.innerHTML = originalHtml;
                lucide.createIcons();
            }, 50);
        }

        // --- 3. 链接清洗 & 图片更新逻辑 ---

        function cleanUrl(input) {
            if (!input) return '';
            let url = input.trim();
            const srcMatch = url.match(/src=["'](.*?)["']/);
            if (srcMatch && srcMatch[1]) return srcMatch[1];
            const urlMatch = url.match(/url\(["']?(.*?)["']?\)/);
            if (urlMatch && urlMatch[1]) return urlMatch[1];
            url = url.replace(/^["']|["']$/g, '');
            return url;
        }

        function updateImageSource(src, isBefore) {
            if (!src) return;

            if (isBefore) {
                beforeImg.src = src;
                scanBefore.src = src;
                previewBefore.src = src;
                
                beforeImg.style.filter = 'none';
                scanBefore.style.filter = 'none';
                previewBefore.style.filter = 'none';
                
                const onLoad = () => { 
                    initZoom(); 
                    detectScanDirection(); 
                    syncScannerImageSize();
                };

                if(scanBefore.complete) onLoad();
                else scanBefore.onload = onLoad;

            } else {
                afterImgUrl = src;
                scanAfter.src = src;
                previewAfter.src = src;
                
                zoomResult.style.backgroundImage = `url('${src}')`;
                initZoom();
                scanAfter.onload = syncScannerImageSize;
            }
        }

        function setupFileUpload(input, isBefore) {
            input.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                const url = URL.createObjectURL(file);
                updateImageSource(url, isBefore);
                const urlInput = isBefore ? urlBefore : urlAfter;
                urlInput.value = '';
            });
        }

        function setupUrlInput(input, isBefore) {
            const handler = function() {
                const cleanVal = cleanUrl(input.value);
                if(cleanVal) updateImageSource(cleanVal, isBefore);
            };
            input.addEventListener('keydown', (e) => { if(e.key === 'Enter') { handler(); input.blur(); }});
            input.addEventListener('change', handler);
        }

        setupFileUpload(uploadBefore, true);
        setupFileUpload(uploadAfter, false);
        setupUrlInput(urlBefore, true);
        setupUrlInput(urlAfter, false);


        // --- 4. 放大镜逻辑 ---
        
        function getZoomLevel() { return parseFloat(lensSizeSlider.value); }

        function updateLensAndBackground() {
            if (!isCursorInside) return;
            const a = beforeImg.getBoundingClientRect();
            let x = lastCursorX - a.left; 
            let y = lastCursorY - a.top;

            const cx = getZoomLevel();
            const lensW = zoomResult.offsetWidth / cx;
            const lensH = zoomResult.offsetHeight / cx;
            
            zoomLens.style.width = lensW + "px";
            zoomLens.style.height = lensH + "px";

            let lensX = x - (lensW / 2);
            let lensY = y - (lensH / 2);

            if (lensX > beforeImg.width - lensW) { lensX = beforeImg.width - lensW; }
            if (lensX < 0) { lensX = 0; }
            if (lensY > beforeImg.height - lensH) { lensY = beforeImg.height - lensH; }
            if (lensY < 0) { lensY = 0; }

            zoomLens.style.left = lensX + "px";
            zoomLens.style.top = lensY + "px";
            zoomResult.style.backgroundSize = (beforeImg.width * cx) + "px " + (beforeImg.height * cx) + "px";
            zoomResult.style.backgroundPosition = "-" + (lensX * cx) + "px -" + (lensY * cx) + "px";
        }

        function moveLens(e) {
            e.preventDefault();
            resultHint.style.display = 'none';
            lastCursorX = e.pageX || (e.touches ? e.touches[0].pageX : 0);
            lastCursorY = e.pageY || (e.touches ? e.touches[0].pageY : 0);
            lastCursorX -= window.scrollX;
            lastCursorY -= window.scrollY;
            updateLensAndBackground();
        }

        function initZoom() {
            zoomResult.style.backgroundImage = "url('" + afterImgUrl + "')";
            if(window.innerWidth >= 768 && beforeImg.complete && beforeImg.naturalHeight > 0) {
                 zoomResult.style.height = beforeImg.offsetHeight + "px";
            }
            const cx = getZoomLevel();
            zoomResult.style.backgroundSize = (beforeImg.width * cx) + "px " + (beforeImg.height * cx) + "px";
        }

        // --- 事件绑定 ---
        imgContainer.addEventListener('mouseenter', () => { zoomLens.style.display = 'block'; isCursorInside = true; initZoom(); });
        imgContainer.addEventListener('mouseleave', () => { zoomLens.style.display = 'none'; isCursorInside = false; });
        imgContainer.addEventListener('mousemove', moveLens);
        imgContainer.addEventListener('touchmove', moveLens, {passive: false});
        imgContainer.addEventListener('touchstart', (e) => { zoomLens.style.display = 'block'; isCursorInside = true; initZoom(); moveLens(e); });
        
        lensSizeSlider.addEventListener('input', function() {
            zoomLevelDisplay.textContent = parseFloat(this.value).toFixed(1) + "x";
            if (isCursorInside) updateLensAndBackground();
            else {
                const cx = parseFloat(this.value);
                zoomResult.style.backgroundSize = (beforeImg.width * cx) + "px " + (beforeImg.height * cx) + "px";
            }
        });
        
        window.addEventListener('resize', initZoom);
        beforeImg.addEventListener('load', initZoom);
        window.addEventListener('load', () => { 
            initZoom(); 
            detectScanDirection();
            syncScannerImageSize();
        });

    </script>
</body>
</html>